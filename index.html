<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Block Atelier</title>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Noto+Sans+JP:wght@400;500;700&family=Space+Grotesk:wght@400;500;600&display=swap');
    :root {
      color: #f8fafc;
      background-color: #020617;
      font-family: 'Space Grotesk', 'Noto Sans JP', system-ui, sans-serif;
    }
    * {
      box-sizing: border-box;
    }
    body {
      margin: 0;
      min-height: 100vh;
      background: radial-gradient(circle at 20% 20%, rgba(59,130,246,0.15), transparent 45%),
        radial-gradient(circle at 90% 0%, rgba(236,72,153,0.12), transparent 40%),
        linear-gradient(180deg, #030712 0%, #01030b 60%, #000000 100%);
      display: flex;
      justify-content: center;
      align-items: stretch;
      padding: 2rem 1rem;
    }
    main {
      width: min(1200px, 100%);
      display: grid;
      grid-template-columns: minmax(0, 1.5fr) minmax(0, 0.9fr);
      gap: 1.4rem;
      align-items: stretch;
    }
    .scene-shell {
      position: relative;
      border-radius: 1.5rem;
      background: linear-gradient(180deg, rgba(15,23,42,0.6), rgba(2,6,23,0.85));
      border: 1px solid rgba(255,255,255,0.08);
      overflow: hidden;
      box-shadow: 0 30px 60px rgba(2,6,23,0.9);
    }
    .scene-shell::after {
      content: '';
      position: absolute;
      inset: 0;
      background: radial-gradient(circle at 20% 20%, rgba(255,255,255,0.05), transparent 55%);
      pointer-events: none;
      opacity: 0.9;
    }
    canvas {
      width: 100%;
      height: 100%;
      display: block;
    }
    .hud {
      position: absolute;
      inset: 1rem;
      pointer-events: none;
      display: flex;
      flex-direction: column;
      gap: 0.65rem;
      z-index: 1;
    }
    .hud p {
      margin: 0;
      font-size: 0.85rem;
      letter-spacing: 0.2em;
      text-transform: uppercase;
      color: rgba(255,255,255,0.75);
    }
    .controls-panel {
      background: rgba(2,6,23,0.95);
      border-radius: 1.5rem;
      border: 1px solid rgba(255,255,255,0.1);
      padding: 1.75rem;
      display: flex;
      flex-direction: column;
      gap: 1rem;
      box-shadow: 0 25px 55px rgba(2,6,23,0.75);
    }
    .controls-panel h1 {
      margin: 0;
      letter-spacing: 0.3em;
      font-size: 1.4rem;
      text-transform: uppercase;
    }
    .controls-panel p {
      margin: 0;
      color: rgba(255,255,255,0.7);
      line-height: 1.6;
    }
    .materials {
      display: flex;
      flex-direction: column;
      gap: 0.55rem;
    }
    .materials button {
      border: 1px solid rgba(255,255,255,0.2);
      background: linear-gradient(135deg, rgba(255,255,255,0.04), rgba(255,255,255,0.01));
      border-radius: 0.9rem;
      padding: 0.75rem 0.9rem;
      color: inherit;
      text-align: left;
      font-size: 0.95rem;
      font-weight: 500;
      cursor: pointer;
      transition: border-color 0.2s ease, transform 0.2s ease;
      display: inline-flex;
      justify-content: space-between;
      align-items: center;
    }
    .materials button.is-active {
      border-color: rgba(20,184,166,0.8);
      transform: translateY(-1px);
      background: linear-gradient(135deg, rgba(20,184,166,0.15), rgba(30,64,175,0.2));
    }
    .materials button span {
      letter-spacing: 0.2em;
      font-size: 0.65rem;
      text-transform: uppercase;
      color: rgba(255,255,255,0.65);
    }
    .materials button small {
      color: rgba(255,255,255,0.65);
      font-size: 0.8rem;
      display: block;
      margin-top: 0.05rem;
    }
    .material-pill {
      width: 12px;
      height: 12px;
      border-radius: 999px;
      margin-left: 0.75rem;
      border: 1px solid rgba(255,255,255,0.3);
    }
    .actions {
      display: flex;
      gap: 0.75rem;
      flex-wrap: wrap;
    }
    .actions button {
      flex: 1;
      min-width: 140px;
      border: none;
      border-radius: 0.9rem;
      padding: 0.85rem 1rem;
      font-size: 0.9rem;
      font-weight: 600;
      letter-spacing: 0.2em;
      text-transform: uppercase;
      background: linear-gradient(135deg, #38bdf8, #6366f1);
      color: #020617;
      cursor: pointer;
      transition: transform 0.2s ease;
      box-shadow: 0 12px 30px rgba(56,189,248,0.3);
    }
    .actions button.secondary {
      background: linear-gradient(135deg, rgba(249,115,22,0.85), rgba(251,191,36,0.8));
      color: #0b0d12;
    }
    .actions button:active {
      transform: translateY(1px);
    }
    .action-log {
      margin: 0;
      padding: 0;
      list-style: none;
      display: flex;
      flex-direction: column;
      gap: 0.35rem;
      max-height: 220px;
      overflow-y: auto;
    }
    .action-log li {
      font-size: 0.9rem;
      color: rgba(248,250,252,0.85);
      padding: 0.6rem 0.8rem;
      border-radius: 0.9rem;
      background: rgba(255,255,255,0.02);
      border: 1px solid rgba(255,255,255,0.05);
    }
    .hint-chip {
      font-size: 0.75rem;
      letter-spacing: 0.2em;
      text-transform: uppercase;
      color: rgba(255,255,255,0.6);
    }
    @media (max-width: 960px) {
      main {
        grid-template-columns: 1fr;
      }
      .scene-shell {
        min-height: 360px;
      }
    }
  </style>
</head>
<body>
  <main>
    <section class="scene-shell">
      <canvas id="world"></canvas>
      <div class="hud">
        <p class="hint-chip">マウス左クリック：ブロック配置 · 右クリック：ブロック破壊</p>
        <p class="hint-chip">Q/E でカメラズーム・OrbitControls で視点移動</p>
      </div>
    </section>
    <aside class="controls-panel">
      <h1>Block Atelier</h1>
      <p>ブロック集めて、思いのままに建築を重ねていこう。素材を選んでクリックで壁や塔を構築し、右クリックで不要なブロックを壊せるよ。</p>
      <div class="materials" id="materialsList"></div>
      <div class="actions">
        <button id="resetWorld" type="button">クラフトリセット</button>
        <button id="toggleGrid" type="button" class="secondary">グリッド切替</button>
      </div>
      <div>
        <p class="hint-chip">操作ログ</p>
        <ul class="action-log" id="actionLog"></ul>
      </div>
    </aside>
  </main>
  <script type="module">
    import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.163.0/build/three.module.js';
    import { OrbitControls } from 'https://cdn.jsdelivr.net/npm/three@0.163.0/examples/jsm/controls/OrbitControls.js';

    const canvas = document.getElementById('world');
    const renderer = new THREE.WebGLRenderer({ canvas, antialias: true, alpha: true });
    renderer.setPixelRatio(window.devicePixelRatio);
    renderer.setSize(canvas.clientWidth, canvas.clientHeight, false);

    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x030712);
    scene.fog = new THREE.Fog(0x030712, 20, 60);

    const camera = new THREE.PerspectiveCamera(60, canvas.clientWidth / canvas.clientHeight, 0.1, 120);
    camera.position.set(12, 10, 12);

    const controls = new OrbitControls(camera, renderer.domElement);
    controls.target.set(0, 1.5, 0);
    controls.enableDamping = true;
    controls.dampingFactor = 0.1;

    const gridHelper = new THREE.GridHelper(32, 32, 0x1d4ed8, 0x374151);
    gridHelper.position.y = -0.5;
    scene.add(gridHelper);

    const lightTop = new THREE.DirectionalLight(0xffffff, 1);
    lightTop.position.set(5, 10, 3);
    scene.add(lightTop);

    const fillLight = new THREE.AmbientLight(0x8da5c2, 0.7);
    scene.add(fillLight);

    const materialData = [
      { type: 'grass', label: '草ブロック', desc: '伸びやかな緑色', color: '#4ade80' },
      { type: 'stone', label: '石レンガ', desc: '重厚で安定感ある', color: '#cbd5f5' },
      { type: 'wood', label: 'オーク材', desc: '建築アクセント', color: '#fbbf24' },
      { type: 'glass', label: 'クリスタル', desc: '光を透かす窓', color: '#38bdf8' },
    ];

    const blockMaterials = new Map(materialData.map((item) => [item.type, new THREE.MeshStandardMaterial({ color: item.color, roughness: 0.55, metalness: 0.1 })]));
    const blockGeometry = new THREE.BoxGeometry(1, 1, 1);
    const blocks = new Map();
    const blockMeshes = [];

    const actionLog = document.getElementById('actionLog');
    const materialsList = document.getElementById('materialsList');
    const resetButton = document.getElementById('resetWorld');
    const toggleGridButton = document.getElementById('toggleGrid');

    let selectedType = materialData[0].type;
    let gridVisible = true;

    function addLog(message) {
      const item = document.createElement('li');
      item.textContent = `${new Date().toLocaleTimeString('ja-JP', { hour12: false })} — ${message}`;
      actionLog.prepend(item);
      while (actionLog.children.length > 6) {
        actionLog.removeChild(actionLog.lastChild);
      }
    }

    function materialButtonFor(item) {
      const button = document.createElement('button');
      button.type = 'button';
      button.dataset.type = item.type;
      button.innerHTML = `<strong>${item.label}</strong><span>${item.desc}</span>`;
      const pill = document.createElement('span');
      pill.className = 'material-pill';
      pill.style.background = item.color;
      button.appendChild(pill);
      button.addEventListener('click', () => {
        selectedType = item.type;
        updateMaterialButtons();
        addLog(`${item.label} を選択`);
      });
      return button;
    }

    function updateMaterialButtons() {
      materialsList.querySelectorAll('button').forEach((button) => {
        button.classList.toggle('is-active', button.dataset.type === selectedType);
      });
    }

    materialData.forEach((item) => {
      materialsList.appendChild(materialButtonFor(item));
    });
    updateMaterialButtons();

    function keyForVector(position) {
      return `${position.x}|${position.y}|${position.z}`;
    }

    function placeBlock(position, type) {
      const key = keyForVector(position);
      if (blocks.has(key)) {
        return null;
      }
      const mesh = new THREE.Mesh(blockGeometry, blockMaterials.get(type));
      mesh.position.copy(position);
      mesh.userData = { type };
      scene.add(mesh);
      blocks.set(key, mesh);
      blockMeshes.push(mesh);
      return mesh;
    }

    function removeBlock(mesh) {
      const key = keyForVector(mesh.position);
      scene.remove(mesh);
      blocks.delete(key);
      const index = blockMeshes.indexOf(mesh);
      if (index !== -1) {
        blockMeshes.splice(index, 1);
      }
    }

    function clearBlocks() {
      blockMeshes.slice().forEach((mesh) => removeBlock(mesh));
    }

    function resetWorld() {
      clearBlocks();
      addBasePlane();
      addLog('地面をリセットしました');
    }

    function addBasePlane() {
      for (let x = -8; x <= 8; x += 1) {
        for (let z = -8; z <= 8; z += 1) {
          placeBlock(new THREE.Vector3(x, 0, z), 'grass');
        }
      }
    }

    addBasePlane();

    let highlightMesh = null;
    function ensureHighlight() {
      if (highlightMesh) {
        return highlightMesh;
      }
      highlightMesh = new THREE.Mesh(
        blockGeometry,
        new THREE.MeshBasicMaterial({ color: 0xffffff, wireframe: true, transparent: true, opacity: 0.7 })
      );
      highlightMesh.visible = false;
      scene.add(highlightMesh);
      return highlightMesh;
    }

    const raycaster = new THREE.Raycaster();
    const pointer = new THREE.Vector2();

    function updatePointer(event) {
      const rect = renderer.domElement.getBoundingClientRect();
      pointer.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
      pointer.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
    }

    function alignToGrid(vec) {
      return new THREE.Vector3(Math.round(vec.x), Math.round(vec.y), Math.round(vec.z));
    }

    function handleIntersect(intersect) {
      const normalMatrix = new THREE.Matrix3().getNormalMatrix(intersect.object.matrixWorld);
      const worldNormal = intersect.face.normal.clone().applyMatrix3(normalMatrix).normalize();
      const position = alignToGrid(intersect.object.position.clone().add(worldNormal));
      return position;
    }

    function handlePointer(event) {
      if (blockMeshes.length === 0) {
        return;
      }
      updatePointer(event);
      raycaster.setFromCamera(pointer, camera);
      const intersects = raycaster.intersectObjects(blockMeshes, false);
      const helper = ensureHighlight();
      if (intersects.length > 0) {
        helper.visible = true;
        helper.position.copy(intersects[0].object.position);
      } else {
        helper.visible = false;
      }
    }

    function onPointerDown(event) {
      if (event.button === 1) {
        return;
      }
      event.preventDefault();
      updatePointer(event);
      raycaster.setFromCamera(pointer, camera);
      const intersects = raycaster.intersectObjects(blockMeshes, false);
      if (intersects.length === 0) {
        return;
      }
      const intersect = intersects[0];
      if (event.button === 2) {
        if (intersect.object.userData?.type) {
          removeBlock(intersect.object);
          addLog('ブロックを破壊しました');
        }
        return;
      }
      const position = handleIntersect(intersect);
      if (!blocks.has(keyForVector(position))) {
        placeBlock(position, selectedType);
        addLog('ブロックを配置しました');
      }
    }

    renderer.domElement.addEventListener('pointermove', handlePointer);
    renderer.domElement.addEventListener('pointerdown', onPointerDown);
    renderer.domElement.addEventListener('contextmenu', (event) => event.preventDefault());

    window.addEventListener('resize', () => {
      const width = canvas.clientWidth;
      const height = canvas.clientHeight;
      camera.aspect = width / height;
      camera.updateProjectionMatrix();
      renderer.setSize(width, height, false);
    });

    resetButton.addEventListener('click', () => {
      resetWorld();
    });

    toggleGridButton.addEventListener('click', () => {
      gridVisible = !gridVisible;
      gridHelper.visible = gridVisible;
      addLog(gridVisible ? 'グリッドを表示' : 'グリッドを非表示');
    });

    function animate() {
      controls.update();
      renderer.render(scene, camera);
      requestAnimationFrame(animate);
    }

    animate();
  </script>
</body>
</html>
