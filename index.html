<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>地球を検証 — GeoGuessr 風チャレンジ</title>
  <style>
    :root {
      font-family: "Noto Sans JP", "Inter", system-ui, sans-serif;
      color: #f7fbff;
      background-color: #02060f;
    }
    * {
      box-sizing: border-box;
    }
    body {
      margin: 0;
      min-height: 100vh;
      background: radial-gradient(circle at top, #2e81ff 0%, transparent 55%),
        linear-gradient(180deg, #02132b, #02060f 65%);
      display: flex;
      justify-content: center;
      align-items: flex-start;
      padding: 2rem 1rem 3rem;
    }
    .app-shell {
      width: min(1100px, 100%);
      display: flex;
      flex-direction: column;
      gap: 1.5rem;
    }
    header {
      text-align: center;
    }
    header h1 {
      margin: 0;
      font-size: clamp(2.5rem, 4vw, 3.75rem);
      letter-spacing: 0.2em;
      text-transform: uppercase;
    }
    header p {
      margin: 0.75rem auto 0;
      max-width: 560px;
      color: #b5c7f5;
      font-size: 1.05rem;
    }
    .game-panel {
      display: grid;
      grid-template-columns: minmax(0, 1.2fr) minmax(280px, 0.8fr);
      gap: 1.5rem;
    }
    canvas {
      width: 100%;
      height: auto;
      border-radius: 1.75rem;
      background: #011835;
      box-shadow: 0 25px 45px rgba(2, 5, 25, 0.9);
      border: 1px solid rgba(255, 255, 255, 0.1);
      display: block;
    }
    .info-panel {
      background: rgba(4, 12, 32, 0.85);
      border-radius: 1.5rem;
      padding: 1.5rem;
      border: 1px solid rgba(255, 255, 255, 0.08);
      box-shadow: 0 30px 60px rgba(0, 0, 0, 0.6);
      display: flex;
      flex-direction: column;
      gap: 1rem;
    }
    .info-card {
      background: rgba(255, 255, 255, 0.03);
      padding: 0.9rem 1rem;
      border-radius: 1rem;
      border: 1px solid rgba(255, 255, 255, 0.08);
    }
    .info-card .label {
      font-size: 0.75rem;
      letter-spacing: 0.25em;
      color: #86b0ff;
      margin: 0;
    }
    .info-value {
      margin: 0.25rem 0 0;
      font-size: 1.35rem;
      font-weight: 600;
    }
    .hint-text {
      margin: 0.25rem 0 0;
      font-size: 1rem;
      line-height: 1.4;
      color: #e2ecff;
    }
    #nextBtn {
      margin-top: 0.5rem;
      width: 100%;
      padding: 0.95rem;
      border-radius: 0.9rem;
      border: none;
      background: linear-gradient(120deg, #5cc7ff, #3f7bff);
      color: #fff;
      font-size: 1rem;
      font-weight: 600;
      cursor: pointer;
      transition: transform 0.2s ease, box-shadow 0.2s ease;
    }
    #nextBtn:active {
      transform: translateY(1px);
    }
    #nextBtn:hover {
      box-shadow: 0 10px 25px rgba(95, 160, 255, 0.6);
    }
    .history {
      max-height: 200px;
      overflow-y: auto;
    }
    .history ul {
      margin: 0.5rem 0 0;
      padding: 0;
      list-style: none;
      display: flex;
      flex-direction: column;
      gap: 0.5rem;
    }
    .history li {
      font-size: 0.9rem;
      color: #dfe7ff;
      padding: 0.35rem 0.5rem;
      border-radius: 0.75rem;
      background: rgba(255, 255, 255, 0.02);
      border: 1px solid rgba(255, 255, 255, 0.08);
      display: flex;
      justify-content: space-between;
      gap: 0.5rem;
    }
    .history strong {
      color: #fff;
    }
    @media (max-width: 900px) {
      .game-panel {
        grid-template-columns: 1fr;
      }
    }
  </style>
</head>
<body>
  <main class="app-shell">
    <header>
      <h1>GeoGlance</h1>
      <p>地球を一望しながら、ヒントを頼りに隠れた都市を当てて距離を競うチャレンジです。クリックした場所からどれだけ近いかを確かめましょう。</p>
    </header>
    <section class="game-panel">
      <canvas id="map" width="960" height="520" aria-label="世界地図を模したキャンバスです"></canvas>
      <div class="info-panel">
        <div class="info-card">
          <p class="label">ヒント</p>
          <p id="clueText" class="hint-text"></p>
        </div>
        <div class="info-card">
          <p class="label">現在のラウンド</p>
          <p id="roundCount" class="info-value">0</p>
        </div>
        <div class="info-card">
          <p class="label">直近の距離</p>
          <p id="distanceText" class="info-value">—</p>
        </div>
        <div class="info-card">
          <p class="label">ベストアンサー</p>
          <p id="bestDistance" class="info-value">—</p>
        </div>
        <div class="info-card">
          <p class="label">正解</p>
          <p id="answerText" class="info-value">—</p>
        </div>
        <button id="nextBtn">次のミッション</button>
        <div class="history">
          <p class="label">履歴</p>
          <ul id="historyList"></ul>
        </div>
      </div>
    </section>
  </main>
  <script>
    const canvas = document.getElementById("map");
    const ctx = canvas.getContext("2d");
    const width = canvas.width;
    const height = canvas.height;

    const locations = [
      {
        name: "パリ, フランス",
        clue: "セーヌ河沿いで光り輝く鉄の塔がある都市",
        lat: 48.8566,
        lon: 2.3522,
      },
      {
        name: "リオデジャネイロ, ブラジル",
        clue: "湾岸に抱かれ、丘の上の巨大キリスト像が見渡す都市",
        lat: -22.9068,
        lon: -43.1729,
      },
      {
        name: "モスクワ, ロシア",
        clue: "赤の広場とクレムリンに近く、白い玉ねぎ屋根が映える都市",
        lat: 55.7558,
        lon: 37.6173,
      },
      {
        name: "シドニー, オーストラリア",
        clue: "湾とオペラハウスの帆がアイコンになっている南半球の港町",
        lat: -33.8688,
        lon: 151.2093,
      },
      {
        name: "ナイロビ, ケニア",
        clue: "サバンナに近い標高の高い首都で、豊かな野生がすぐ近くに",
        lat: -1.2921,
        lon: 36.8219,
      },
      {
        name: "トロント, カナダ",
        clue: "世界一高い塔 CN タワーが湖畔でそびえる多文化都市",
        lat: 43.6532,
        lon: -79.3832,
      },
      {
        name: "ソウル, 韓国",
        clue: "漢江のほとりで、古い城壁と近代都市が交差する場所",
        lat: 37.5665,
        lon: 126.978,
      },
      {
        name: "カイロ, エジプト",
        clue: "ナイル川沿い、ピラミッドと共に歴史を刻む都市",
        lat: 30.0444,
        lon: 31.2357,
      },
      {
        name: "メキシコシティ, メキシコ",
        clue: "高原に広がり、フリーダ・カーロゆかりの文化が息づく首都",
        lat: 19.4326,
        lon: -99.1332,
      },
      {
        name: "ニューヨーク, アメリカ",
        clue: "自由の女神が見守る島々と摩天楼が連なる東海岸の大都市",
        lat: 40.7128,
        lon: -74.006,
      },
    ];

    const continentShapes = [
      {
        color: "rgba(255, 255, 255, 0.15)",
        points: [
          [0.05, 0.55],
          [0.25, 0.45],
          [0.35, 0.55],
          [0.28, 0.7],
          [0.15, 0.65],
        ],
      },
      {
        color: "rgba(255, 255, 255, 0.13)",
        points: [
          [0.35, 0.43],
          [0.4, 0.32],
          [0.52, 0.3],
          [0.58, 0.38],
          [0.5, 0.48],
          [0.4, 0.45],
        ],
      },
      {
        color: "rgba(255, 255, 255, 0.1)",
        points: [
          [0.1, 0.25],
          [0.2, 0.2],
          [0.38, 0.25],
          [0.45, 0.22],
          [0.47, 0.12],
          [0.3, 0.05],
        ],
      },
      {
        color: "rgba(255, 255, 255, 0.12)",
        points: [
          [0.55, 0.58],
          [0.7, 0.52],
          [0.8, 0.4],
          [0.88, 0.4],
          [0.92, 0.5],
          [0.82, 0.65],
          [0.68, 0.68],
        ],
      },
    ];

    const state = {
      current: null,
      guess: null,
      rounds: 0,
      bestDistance: null,
      history: [],
    };

    const clueText = document.getElementById("clueText");
    const roundCount = document.getElementById("roundCount");
    const distanceText = document.getElementById("distanceText");
    const bestDistance = document.getElementById("bestDistance");
    const answerText = document.getElementById("answerText");
    const historyList = document.getElementById("historyList");
    const nextBtn = document.getElementById("nextBtn");

    function xyToLatLng(x, y) {
      const lng = (x / width) * 360 - 180;
      const lat = 90 - (y / height) * 180;
      return { lat, lon: lng };
    }

    function latLngToXY(lat, lon) {
      const x = ((lon + 180) / 360) * width;
      const y = ((90 - lat) / 180) * height;
      return { x, y };
    }

    function haversine(lat1, lon1, lat2, lon2) {
      const toRad = (deg) => (deg * Math.PI) / 180;
      const R = 6371;
      const dLat = toRad(lat2 - lat1);
      const dLon = toRad(lon2 - lon1);
      const a =
        Math.sin(dLat / 2) * Math.sin(dLat / 2) +
        Math.cos(toRad(lat1)) *
          Math.cos(toRad(lat2)) *
          Math.sin(dLon / 2) *
          Math.sin(dLon / 2);
      const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
      return R * c;
    }

    function drawMap() {
      const grd = ctx.createLinearGradient(0, 0, 0, height);
      grd.addColorStop(0, "#04224d");
      grd.addColorStop(1, "#010b1f");
      ctx.fillStyle = grd;
      ctx.fillRect(0, 0, width, height);

      ctx.save();
      ctx.strokeStyle = "rgba(255,255,255,0.1)";
      ctx.lineWidth = 1;
      for (let i = 1; i <= 12; i++) {
        const x = (width / 12) * i;
        ctx.beginPath();
        ctx.moveTo(x, 0);
        ctx.lineTo(x, height);
        ctx.stroke();
      }
      for (let i = 1; i <= 6; i++) {
        const y = (height / 6) * i;
        ctx.beginPath();
        ctx.moveTo(0, y);
        ctx.lineTo(width, y);
        ctx.stroke();
      }
      ctx.restore();

      continentShapes.forEach((shape) => {
        ctx.beginPath();
        shape.points.forEach((point, index) => {
          const px = point[0] * width;
          const py = point[1] * height;
          if (index === 0) {
            ctx.moveTo(px, py);
          } else {
            ctx.lineTo(px, py);
          }
        });
        ctx.closePath();
        ctx.fillStyle = shape.color;
        ctx.fill();
      });

      if (state.current && state.guess) {
        const targetPoint = latLngToXY(state.current.lat, state.current.lon);
        ctx.fillStyle = "#fbc02d";
        ctx.beginPath();
        ctx.arc(targetPoint.x, targetPoint.y, 7, 0, Math.PI * 2);
        ctx.fill();
        ctx.strokeStyle = "rgba(255, 178, 15, 0.7)";
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(targetPoint.x - 12, targetPoint.y);
        ctx.lineTo(targetPoint.x + 12, targetPoint.y);
        ctx.moveTo(targetPoint.x, targetPoint.y - 12);
        ctx.lineTo(targetPoint.x, targetPoint.y + 12);
        ctx.stroke();
      }

      if (state.guess) {
        const guessPoint = latLngToXY(state.guess.lat, state.guess.lon);
        ctx.fillStyle = "#ff5f8e";
        ctx.beginPath();
        ctx.arc(guessPoint.x, guessPoint.y, 9, 0, Math.PI * 2);
        ctx.fill();
        ctx.strokeStyle = "rgba(255, 95, 142, 0.8)";
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(guessPoint.x - 14, guessPoint.y);
        ctx.lineTo(guessPoint.x + 14, guessPoint.y);
        ctx.moveTo(guessPoint.x, guessPoint.y - 14);
        ctx.lineTo(guessPoint.x, guessPoint.y + 14);
        ctx.stroke();
      }
    }

    function updateUI() {
      clueText.textContent = state.current?.clue ?? "クリックして新しいミッションを始めよう。";
      roundCount.textContent = state.rounds;
      distanceText.textContent = state.guess
        ? `${state.lastDistance.toFixed(1)} km`
        : "—";
      bestDistance.textContent = state.bestDistance ? `${state.bestDistance.toFixed(1)} km` : "—";
      answerText.textContent = state.guess ? state.current.name : "—";

      historyList.innerHTML = state.history
        .map(
          (entry) => `
            <li>
              <strong>${entry.name}</strong>
              <span>${entry.distance.toFixed(1)} km</span>
            </li>
          `
        )
        .join("");
    }

    function startRound() {
      state.rounds += 1;
      state.current = locations[Math.floor(Math.random() * locations.length)];
      state.guess = null;
      state.lastDistance = null;
      drawMap();
      updateUI();
    }

    canvas.addEventListener("click", (event) => {
      if (!state.current) {
        return;
      }
      const rect = canvas.getBoundingClientRect();
      const x = event.clientX - rect.left;
      const y = event.clientY - rect.top;
      const guess = xyToLatLng(x, y);
      state.guess = guess;
      const distance = haversine(state.current.lat, state.current.lon, guess.lat, guess.lon);
      state.lastDistance = distance;
      if (state.bestDistance === null || distance < state.bestDistance) {
        state.bestDistance = distance;
      }
      state.history.unshift({ name: state.current.name, distance });
      if (state.history.length > 5) {
        state.history.pop();
      }
      drawMap();
      updateUI();
    });

    nextBtn.addEventListener("click", () => {
      startRound();
    });

    drawMap();
    updateUI();
    startRound();
  </script>
</body>
</html>
