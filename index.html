<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>スタック・スカイランナー</title>
  <style>
    :root {
      font-family: "Noto Sans JP", "Inter", system-ui, sans-serif;
      color: #f8fbff;
      background-color: #01030b;
    }
    * {
      box-sizing: border-box;
    }
    body {
      margin: 0;
      min-height: 100vh;
      background: radial-gradient(circle at 20% 20%, rgba(80, 135, 255, 0.2), transparent 45%),
        radial-gradient(circle at 80% 0%, rgba(255, 149, 255, 0.08), transparent 35%),
        linear-gradient(180deg, #040714, #01030b 60%);
      display: flex;
      justify-content: center;
      align-items: flex-start;
      padding: 2rem 1rem 3rem;
    }
    .app-shell {
      width: min(1200px, 100%);
      display: flex;
      flex-direction: column;
      gap: 1.5rem;
    }
    header {
      text-align: center;
    }
    header h1 {
      margin: 0;
      font-size: clamp(2.8rem, 4vw, 4rem);
      letter-spacing: 0.3em;
      text-transform: uppercase;
    }
    header p {
      margin: 0.75rem auto 0;
      max-width: 640px;
      color: #8fa3ff;
      font-size: 1.05rem;
      line-height: 1.5;
    }
    .game-layout {
      display: grid;
      grid-template-columns: minmax(0, 1.2fr) minmax(260px, 0.8fr);
      gap: 1.5rem;
    }
    .canvas-shell {
      position: relative;
    }
    canvas {
      width: 100%;
      height: auto;
      border-radius: 1.5rem;
      background: #020a1f;
      box-shadow: 0 25px 60px rgba(2, 5, 25, 0.9);
      border: 1px solid rgba(255, 255, 255, 0.08);
      display: block;
    }
    .canvas-shell::after {
      content: "↑ Space / クリックでブロックを落とす";
      position: absolute;
      left: 50%;
      top: 1rem;
      transform: translateX(-50%);
      padding: 0.35rem 0.85rem;
      border-radius: 999px;
      font-size: 0.9rem;
      letter-spacing: 0.2em;
      background: rgba(0, 0, 0, 0.55);
      border: 1px solid rgba(255, 255, 255, 0.15);
    }
    .side-panel {
      display: flex;
      flex-direction: column;
      gap: 1rem;
    }
    .panel-card {
      background: rgba(8, 17, 38, 0.95);
      border-radius: 1.25rem;
      padding: 1.3rem 1.25rem;
      border: 1px solid rgba(255, 255, 255, 0.08);
      box-shadow: inset 0 0 35px rgba(255, 255, 255, 0.04);
    }
    .panel-card .label {
      font-size: 0.7rem;
      letter-spacing: 0.35em;
      color: #7fb0ff;
      margin: 0;
    }
    .panel-card .value {
      margin: 0.5rem 0 0;
      font-size: 1.9rem;
      font-weight: 700;
      color: #fffdf7;
    }
    .panel-card .note {
      margin-top: 0.4rem;
      font-size: 0.95rem;
      color: #c7d5ff;
      line-height: 1.4;
    }
    .button-group {
      display: flex;
      flex-direction: column;
      gap: 0.8rem;
    }
    button {
      border: none;
      border-radius: 0.9rem;
      padding: 0.95rem;
      font-size: 1rem;
      font-weight: 600;
      cursor: pointer;
      transition: transform 0.15s ease, box-shadow 0.2s ease;
      color: #fff;
    }
    #dropBtn {
      background: linear-gradient(135deg, #facc15, #f97316);
      box-shadow: 0 12px 30px rgba(250, 115, 22, 0.3);
    }
    #restartBtn {
      background: rgba(255, 255, 255, 0.08);
      border: 1px solid rgba(255, 255, 255, 0.3);
      box-shadow: 0 15px 40px rgba(0, 0, 0, 0.4);
    }
    button:active {
      transform: translateY(1px);
    }
    button:hover {
      box-shadow: 0 18px 35px rgba(255, 255, 255, 0.15);
    }
    .status-line {
      text-align: center;
      font-size: 0.95rem;
      color: #e4ecff;
      min-height: 2rem;
    }
    .status-line strong {
      color: #fff;
    }
    .history-list {
      max-height: 180px;
      overflow-y: auto;
      margin: 0.35rem 0 0;
      padding: 0;
      list-style: none;
      display: flex;
      flex-direction: column;
      gap: 0.45rem;
    }
    .history-list li {
      font-size: 0.85rem;
      color: #d1d9ff;
      padding: 0.35rem 0.75rem;
      border-radius: 0.75rem;
      background: rgba(255, 255, 255, 0.02);
      border: 1px solid rgba(255, 255, 255, 0.05);
      display: flex;
      justify-content: space-between;
      letter-spacing: 0.1em;
    }
    .history-list span {
      color: #fff;
    }
    @media (max-width: 900px) {
      .game-layout {
        grid-template-columns: 1fr;
      }
      .canvas-shell::after {
        top: 0.4rem;
      }
    }
  </style>
</head>
<body>
  <main class="app-shell">
    <header>
      <h1>Stack Sky Runner</h1>
      <p>ブロックをタイミングよく落としてタワーを積み上げ、カメラ位置を上げながらどこまでの高さを記録できるか競います。</p>
    </header>
    <section class="game-layout">
      <div class="canvas-shell">
        <canvas id="stage" width="980" height="620"></canvas>
      </div>
      <div class="side-panel">
        <div class="panel-card">
          <p class="label">現在の高さ</p>
          <p id="towerHeight" class="value">0 階</p>
          <p class="note">成功するとブロックが次々上昇。ズレすぎるとゲームオーバーです。</p>
        </div>
        <div class="panel-card">
          <p class="label">ベスト記録</p>
          <p id="bestHeight" class="value">0 階</p>
        </div>
        <div class="status-line">
          <span id="statusText">準備完了。クリックでブロックを落としてね！</span>
        </div>
        <div class="button-group">
          <button id="dropBtn">ブロックを落とす</button>
          <button id="restartBtn">最初から</button>
        </div>
        <div class="panel-card">
          <p class="label">履歴</p>
          <ul id="historyList" class="history-list"></ul>
        </div>
      </div>
    </section>
  </main>
  <script>
    const canvas = document.getElementById("stage");
    const ctx = canvas.getContext("2d");
    const width = canvas.width;
    const height = canvas.height;
    const blockHeight = 32;
    const palette = ["#ff5f6d", "#facc15", "#4ade80", "#22d3ee", "#a855f7", "#fdba74"];

    function createBaseBlock() {
      return {
        x: 0,
        z: 0,
        y: blockHeight,
        width: 320,
        depth: 200,
        height: blockHeight,
        color: "#6366f1",
      };
    }

    const state = {
      stack: [createBaseBlock()],
      current: null,
      gameOver: false,
      bestHeight: 0,
      lastShots: [],
    };

    const towerHeightEl = document.getElementById("towerHeight");
    const bestHeightEl = document.getElementById("bestHeight");
    const statusText = document.getElementById("statusText");
    const historyList = document.getElementById("historyList");
    const dropBtn = document.getElementById("dropBtn");
    const restartBtn = document.getElementById("restartBtn");

    function createMover(reference, axis) {
      return {
        x: reference.x,
        z: reference.z,
        y: reference.y + blockHeight,
        width: reference.width,
        depth: reference.depth,
        height: blockHeight,
        axis,
        speed: 3 + state.stack.length * 0.15,
        color: palette[Math.floor(Math.random() * palette.length)],
      };
    }

    function spawnNextBlock(axis) {
      const last = state.stack[state.stack.length - 1];
      state.current = createMover(last, axis);
    }

    function resetGame() {
      state.stack = [createBaseBlock()];
      state.gameOver = false;
      state.lastShots = [];
      spawnNextBlock("x");
      updateStats();
    }

    function shadeColor(color, percent) {
      const f = parseInt(color.slice(1), 16);
      const t = percent < 0 ? 0 : 255;
      const p = Math.abs(percent) / 100;
      let R = f >> 16;
      let G = (f >> 8) & 0xff;
      let B = f & 0xff;
      R = Math.round(R + (t - R) * p);
      G = Math.round(G + (t - G) * p);
      B = Math.round(B + (t - B) * p);
      return `#${(R << 16 | G << 8 | B).toString(16).padStart(6, "0")}`;
    }

    function project(x, y, z) {
      const scale = 0.55;
      const isoX = (x - z) * scale;
      const isoY = (x + z) * scale * 0.26;
      return {
        x: width / 2 + isoX,
        y: height - y * 0.7 - isoY - 60,
      };
    }

    function drawBlock(block, isCurrent = false) {
      const w = block.width;
      const d = block.depth;
      const h = block.height;
      const topY = block.y;
      const bottomY = topY - h;
      const points = {
        topLeft: project(block.x - w / 2, topY, block.z - d / 2),
        topRight: project(block.x + w / 2, topY, block.z - d / 2),
        topFar: project(block.x + w / 2, topY, block.z + d / 2),
        topBack: project(block.x - w / 2, topY, block.z + d / 2),
        bottomLeft: project(block.x - w / 2, bottomY, block.z - d / 2),
        bottomRight: project(block.x + w / 2, bottomY, block.z - d / 2),
        bottomFar: project(block.x + w / 2, bottomY, block.z + d / 2),
        bottomBack: project(block.x - w / 2, bottomY, block.z + d / 2),
      };
      const topColor = isCurrent ? shadeColor(block.color, 25) : block.color;
      const leftColor = shadeColor(block.color, -8);
      const rightColor = shadeColor(block.color, -18);

      ctx.beginPath();
      ctx.moveTo(points.topLeft.x, points.topLeft.y);
      ctx.lineTo(points.topRight.x, points.topRight.y);
      ctx.lineTo(points.topFar.x, points.topFar.y);
      ctx.lineTo(points.topBack.x, points.topBack.y);
      ctx.closePath();
      ctx.fillStyle = topColor;
      ctx.fill();
      ctx.strokeStyle = "rgba(255,255,255,0.08)";
      ctx.stroke();

      ctx.beginPath();
      ctx.moveTo(points.topLeft.x, points.topLeft.y);
      ctx.lineTo(points.topBack.x, points.topBack.y);
      ctx.lineTo(points.bottomBack.x, points.bottomBack.y);
      ctx.lineTo(points.bottomLeft.x, points.bottomLeft.y);
      ctx.closePath();
      ctx.fillStyle = leftColor;
      ctx.fill();

      ctx.beginPath();
      ctx.moveTo(points.topRight.x, points.topRight.y);
      ctx.lineTo(points.topFar.x, points.topFar.y);
      ctx.lineTo(points.bottomFar.x, points.bottomFar.y);
      ctx.lineTo(points.bottomRight.x, points.bottomRight.y);
      ctx.closePath();
      ctx.fillStyle = rightColor;
      ctx.fill();
    }

    function drawScene() {
      const gradient = ctx.createLinearGradient(0, 0, 0, height);
      gradient.addColorStop(0, "#0a1226");
      gradient.addColorStop(1, "#01030b");
      ctx.fillStyle = gradient;
      ctx.fillRect(0, 0, width, height);

      ctx.save();
      ctx.strokeStyle = "rgba(255,255,255,0.08)";
      ctx.lineWidth = 1;
      for (let i = 0; i < 12; i++) {
        ctx.beginPath();
        ctx.moveTo((width / 12) * i, 0);
        ctx.lineTo((width / 12) * i, height);
        ctx.stroke();
      }
      for (let j = 0; j < 8; j++) {
        ctx.beginPath();
        ctx.moveTo(0, (height / 8) * j);
        ctx.lineTo(width, (height / 8) * j);
        ctx.stroke();
      }
      ctx.restore();

      state.stack.forEach((block) => drawBlock(block));
      if (state.current) {
        drawBlock(state.current, true);
      }

      if (state.gameOver) {
        ctx.fillStyle = "rgba(0, 0, 0, 0.65)";
        ctx.fillRect(0, height / 2 - 60, width, 120);
        ctx.font = "bold 42px Inter, sans-serif";
        ctx.fillStyle = "#ffe066";
        ctx.textAlign = "center";
        ctx.fillText("GAME OVER", width / 2, height / 2 - 4);
        ctx.font = "20px Inter, sans-serif";
        ctx.fillStyle = "rgba(255,255,255,0.8)";
        ctx.fillText("リセットして再挑戦！", width / 2, height / 2 + 28);
      }
    }

    function updateMover() {
      if (!state.current || state.gameOver) {
        return;
      }
      const axis = state.current.axis;
      state.current[axis] += state.current.speed;
      if (state.current[axis] > 420 || state.current[axis] < -420) {
        state.current.speed *= -1;
      }
    }

    function recordShot(entry) {
      state.lastShots.unshift(entry);
      if (state.lastShots.length > 5) {
        state.lastShots.pop();
      }
      historyList.innerHTML = state.lastShots
        .map((entry) => `<li><strong>${entry.height} 階</strong><span>${entry.distance.toFixed(1)} km</span></li>`)
        .join("");
    }

    function updateStats() {
      const height = state.stack.length - 1;
      towerHeightEl.textContent = `${height} 階`;
      bestHeightEl.textContent = `${Math.max(state.bestHeight, height)} 階`;
      statusText.textContent = state.gameOver
        ? "ゲームオーバー。最初から積み上げよう。"
        : "タイミングよくブロックを落としていこう！";
    }

    function dropBlock() {
      if (!state.current || state.gameOver) {
        return;
      }
      const last = state.stack[state.stack.length - 1];
      const axis = state.current.axis;
      const sizeProp = axis === "x" ? "width" : "depth";
      const currentMin = state.current[axis] - state.current[sizeProp] / 2;
      const currentMax = state.current[axis] + state.current[sizeProp] / 2;
      const lastMin = last[axis] - last[sizeProp] / 2;
      const lastMax = last[axis] + last[sizeProp] / 2;
      const overlapStart = Math.max(currentMin, lastMin);
      const overlapEnd = Math.min(currentMax, lastMax);
      const overlap = overlapEnd - overlapStart;
      if (overlap <= 4) {
        state.gameOver = true;
        state.bestHeight = Math.max(state.bestHeight, state.stack.length - 1);
        updateStats();
        return;
      }
      const nextAxis = axis === "x" ? "z" : "x";
      const nextBlock = {
        x: axis === "x" ? (overlapStart + overlapEnd) / 2 : last.x,
        z: axis === "x" ? last.z : (overlapStart + overlapEnd) / 2,
        y: last.y + blockHeight,
        width: axis === "x" ? overlap : last.width,
        depth: axis === "x" ? last.depth : overlap,
        height: blockHeight,
        color: state.current.color,
      };
      state.stack.push(nextBlock);
      state.bestHeight = Math.max(state.bestHeight, state.stack.length - 1);
      recordShot({ height: state.stack.length - 1, distance: overlap });
      spawnNextBlock(nextAxis);
      updateStats();
    }

    dropBtn.addEventListener("click", dropBlock);
    restartBtn.addEventListener("click", resetGame);
    canvas.addEventListener("click", dropBlock);
    document.addEventListener("keydown", (event) => {
      if (event.code === "Space") {
        event.preventDefault();
        dropBlock();
      }
    });

    function loop() {
      updateMover();
      drawScene();
      requestAnimationFrame(loop);
    }

    resetGame();
    loop();
  </script>
</body>
</html>
